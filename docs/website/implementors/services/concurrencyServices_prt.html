<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
  <HEAD>
    <META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
    <!-- TO CHANGE: change the document title -->
    <TITLE>
      uPortal Concurrency Services
    </TITLE>
    <META NAME="GENERATOR" CONTENT="OpenOffice.org 1.0.1  (Linux)">
    <META NAME="AUTHOR" CONTENT="Dan Ellentuck">
  </HEAD>
  <BODY LANG="en-US" TEXT="#000000">
          <br>
              <!-- TO CHANGE: main body goes HERE <<<<<<<<<<<<<<<<<< -->
                                                                 <!-- start cut this section to put into jasig table cell format -->
         
      <div align="center"><big><big>uPortal Concurrency Services</big></big><br>
   </div>
   <br>
  <big><br>
 Contents<br>
  </big>        
      <blockquote><a href="#Goals">Goals</a><br>
    <a href="#The_Need_for_a_Concurrency_Framework">The Need for a Concurrency
 Framework</a><br>
    <a href="#Package_Structure">Package Structure</a><br>
    <a href="#Caching_API">Caching API</a><br>
    <a href="#Locking_API">Locking API</a><br>
    <a href="#Using_the_Locking_and_Caching_Services">Using the Caching and
 Locking Services</a><br>
    <a href="#Notes_on_Service_Implementations">Notes on Service Implementations</a><br>
  </blockquote>
  <br>
  <br>
   <big><a name="Goals"></a>Goals</big><br>
   
      <p>   The concurrency packages, org.jasig.portal.concurrency.*, are
offered as  building blocks for portal developers who want to create persistence
support  for portal entities.&nbsp; The locking and caching packages are
self-contained  &#8220;mini-frameworks&#8221; exposed as portal services via classes
in org.jasig.portal.services.  &nbsp;</p>
    
      <p>   The concurrency framework operates on entities, persistent objects
uniquely  identified by a type and a key.&nbsp; As currently implemented,
these packages  cache entities in memory for fast access and lock entities
for either reading  or writing.&nbsp; Perhaps in the future, we will abstract
the operations of creating, finding and updating them. &nbsp;</p>
    <big><a name="The_Need_for_a_Concurrency_Framework"></a>The Need for
a Concurrency Framework</big><br>
   
      <p>   The need for these services arose because of performance problems
in the  groups framework.&nbsp; Groups are relatively expensive to create
and are  frequently reused.&nbsp; They needed to be cached, and since they
are updatable,  they also needed to be locked. &nbsp;</p>
    
      <p>Caching objects in a JVM is simple; put them in a Map and store
the Map  in a static variable.&nbsp; It&#8217;s not that hard to lock cached entities
either.&nbsp;  The complexity arises when caching and locking must work in
a cloned server  environment.&nbsp; Now, caches must be synchronized with
their peers and locks must hold across multiple JVM&#8217;s. &nbsp;</p>
   
      <p>Although there are some decent commercial caching products available,
they  are not appropriate for an open source project.&nbsp; Unfortunately,
the open  source solutions I looked at were too big, too ugly, too early
or just not  right (I know, picky, picky.) &nbsp;I think the most promising
is Turbine&#8217;s  Java Caching System or JCS (see <a
 href="http://jakarta.apache.org/turbine/jcs">http://jakarta.apache.org/turbine/jcs</a>), 
 an approximate implementation of the JCache specification (see <a
 href="http://jcp.org/jsr/detail/107.jsp">http://jcp.org/jsr/detail/107.jsp</a>), 
 which in turn, describes the Oracle9i caching framework.&nbsp; JCS promises 
 to be an efficient, full-featured framework, but it is still in development 
 and it does not do locking.&nbsp; Hence, at least in the interim, uPortal 
 needs some home grown locking and caching support.&nbsp; The concurrency 
packages are intended as a common solution that can be used not just by groups 
but by any type of portal entity and replaced when a better alternative is 
found.&nbsp; They are not intended to replace or compete with full-featured 
commercial or open source frameworks. &nbsp;</p>
    <br>
   <big><a name="Package_Structure"></a>Package Structure </big><br>
   
      <p>   The concurrency services operate on IBasicEntities, objects that
implement        <code>org.jasig.portal.IBasicEntity</code>, defined as follows:
 </p>
       
      <blockquote><code>public interface IBasicEntity {</code><br>
     <code>&nbsp; public org.jasig.portal.EntityIdentifier getEntityIdentifier();</code><br>
     <code>}</code><br>
   </blockquote>
  
      <p>An EntityIdentifier has a key and type that uniquely identify its
underlying  entity. &nbsp;Two EntityIdentifiers with the same key and type
refer to the  same underlying entity (although they may belong to different
IBasicEntities.) </p>
   
      <p>The package <code>org.jasig.portal.concurrency</code> defines some
basic  types to support concurrency: a lock (IEntityLock), a cache (IEntityCache),
 and services for locking and caching (IEntityLockService and IEntityCachingService).&nbsp;
 It also contains the locking and caching Exceptions:</p>
           
      <blockquote><code>org.jasig.portal.concurrency<br>
     </code>               
        <blockquote><code></code><code>IEntityCache</code><br>
       <code>IEntityCachingService</code><br>
       <code>IEntityCachingServiceFactory</code><br>
       <code>IEntityLock</code><br>
       <code>IEntityLockService</code><br>
       <code>IEntityLockServiceFactory</code><br>
       <code>CachingException</code><br>
       <code>LockingException</code><br>
       <code></code></blockquote>
   </blockquote>
    
      <p>The individual locking and caching packages contain reference implementations 
 of the basic types, plus some supporting classes.</p>
        
      <blockquote><code>org.jasig.portal.concurrency.caching</code>      
       
        <blockquote><code>CachedEntityInvalidation<br>
   LRUCache<br>
   RDBMCachedEntityInvalidationStore<br>
   ReferenceEntityCache<br>
   ReferenceEntityCachingService<br>
   ReferenceEntityCachingServiceFactory<br>
   ReferenceInvalidatingEntityCache<br>
       </code></blockquote>
     <code>org.jasig.portal.concurrency.locking</code><br>
     <code></code>               
        <blockquote><code>EntityLockImpl<br>
   IEntityLockStore<br>
   MemoryEntityLockStore<br>
   RDBMEntityLockStore<br>
   ReferenceEntityLockService<br>
   ReferenceEntityLockServiceFactory<br>
       </code></blockquote>
   </blockquote>
   <big><a name="Caching_API"></a>Caching API</big><br>
    
      <p>IEntityCachingService defines a minimal api for caching and retrieving 
IBasicEntities.&nbsp; An IEntityCachingService manages a number of IEntityCaches. 
&nbsp;Each IEntityCache holds entities of a given type, (the type returned 
by <code>IEntityCache.getEntityType()</code>). &nbsp;This type must be known 
to the portal (see <code>org.jasig.portal.EntityTypes</code>.)&nbsp; In a 
multi-server environment, caches must be able to synchronize themselves with 
their peers on other servers, but this is not part of the api: </p>
        
      <blockquote><code> public interface IEntityCachingService {</code><br>
    <code> &nbsp; void add(IBasicEntity entity) throws CachingException;<br>
    </code><code></code><code>&nbsp; IBasicEntity get(Class type, String
key);<br>
    </code><code></code><code>&nbsp; void remove(Class type, String key);<br>
    </code><code></code><code>&nbsp; void update(IBasicEntity entity) throws 
CachingException;</code><br>
    <code> }</code><br>
  </blockquote>
   <big><a name="Locking_API"></a>Locking API</big><br>
   <br>
    
      <p>The interface IEntityLockService defines an api for acquiring lock
objects,  IEntityLocks, that can be used to control concurrent access to
IBasicEntities.&nbsp;  The entity type of the IBasicEntity must be known
to the portal (see <code>org.jasig.portal.EntityTypes</code>.)&nbsp;  A lock
is associated with a particular entity and has an owner, a lockType  and
an expirationTime.&nbsp; Currently supported lock types are<code> IEntityLockService.READ_LOCK</code>,
 which is shared, and <code>IEntityLockService.WRITE_LOCK</code>, which is
 exclusive. &nbsp;To lock an entity for update, ask the service for a write
 lock:  </p>
        
      <blockquote><code> int lockType = IEntityLockService.WRITE_LOCK;</code><br>
    <code> IBasicEntity entity = getEntityFromSomewhere();</code><br>
    <code> IEntityLock lock = svc.newLock(entity, lockType, lockOwner);</code><br>
    <code></code></blockquote>
    
      <p>If there is no conflicting lock on the entity, the service responds
with  the requested lock.&nbsp; If another lock owner holds a conflicting
lock,  the service throws a LockingException.&nbsp; If the service returns
the lock, no other client will get be able to get a conflicting lock. From
then on, communication with the service is via the lock: </p>
        
      <blockquote><code> lock.convert(int newType);</code><br>
    <code> lock.isValid();</code><br>
    <code> lock.release();</code><br>
    <code> lock.renew();</code><br>
    <code></code></blockquote>
    
      <p>The complete service api is as follows: </p>
        
      <blockquote><code> public interface IEntityLockingService {</code><br>
    <code> &nbsp; public void convert(IEntityLock lock, int newType) </code><code>throws
 LockingException;</code><br>
    <code> &nbsp; public void convert(IEntityLock lock, int newType, int
durationSecs)</code><br>
    <code> &nbsp;&nbsp;&nbsp; throws LockingException;</code><br>
    <code> &nbsp; public boolean existsInStore(IEntityLock lock) </code><code>throws
 LockingException;</code><br>
    <code> &nbsp; public boolean isValid(IEntityLock lock) </code><code>throws
 LockingException;</code><br>
    <code> &nbsp; public IEntityLock newLock</code><code>(IBasicEntity entity,
 int lockType, String owner) </code><br>
    <code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; throws LockingException;</code><br>
    <code> &nbsp; public IEntityLock newLock</code><code>(IBasicEntity entity,
 int lockType, String owner, int<br>
  &nbsp; &nbsp; &nbsp; durationSecs) </code><code>throws LockingException;</code><br>
    <code> &nbsp; public void release(IEntityLock lock) </code><code>throws
 LockingException;</code><br>
    <code> &nbsp; public void renew(IEntityLock lock) </code><code>throws 
LockingException;</code><br>
    <code> &nbsp; public void renew(IEntityLock lock, int durationSecs) </code><br>
    <code> &nbsp;&nbsp;&nbsp; throws LockingException;</code><br>
    <code> }</code><br>
  </blockquote>
   <big><a name="Using_the_Locking_and_Caching_Services"></a>Using the Caching
 and Locking Services</big><br>
    
      <p>The caching and locking APIs are accessed by portal clients via
service fa&ccedil;ades located in <code>org.jasig.portal.services</code>,
EntityCachingService and EntityLockService.&nbsp; These classes serve as
bootstraps for service implementations specified in portal.properties. &nbsp;One
way to plug in an external locking or caching service would be to create
an alternate implementation of the service that adapts the external service
to the portal interface.</p>
    
      <p>The caching fa&ccedil;ade simply duplicates the api of the service
interface.&nbsp;  Caching consists of asking the service to add, retrieve,
update and remove  elements from the cache, e.g.:</p>
        
      <blockquote><code> // Retrieve the entity from its store:</code><br>
    <code> String key = getEntityKey();</code><br>
    <code> IBasicEntity ent = findEntity(key);</code><br>
    <code></code><br>
    <code> // Cache the entity:</code><br>
    <code> EntityCachingService.add(ent);</code><br>
    <code>...</code><br>
    <code> // Retrieve the entity from the cache:</code><br>
    <code> Class type = getEntityClass();</code><br>
    <code> IBasicEntity anotherReferenceToTheEntity = EntityCachingService.get(type,
 key);</code><br>
    <code> ...</code><br>
    <code> // Change the entity and then notify the cache:</code><br>
    <code> EntityCachingService.update(ent);&nbsp;&nbsp;&nbsp; // notifies
 peer caches.</code><br>
    <br>
    <code> // Or delete the entity and notify the cache:</code><br>
    <code> EntityCachingService.remove(type, key); // notifies peer caches.</code><br>
    <code></code><code></code></blockquote>
        
      <p>The EntityLockService fa&ccedil;ade lets clients do one single thing,
 acquire a lock on an entity: </p>
        
      <blockquote><code> IBasicEntity entity = getEntityFromSomewhere(type, 
key);</code><br>
    <code> String owner = getThePortalUserId();</code><br>
    <code> IEntityLock lock = </code><code>EntityLockService.instance().newWriteLock(entity,
 owner);</code><br>
    <code></code></blockquote>
   Or perhaps:        
      <blockquote><code> IEntityLock lock = EntityLockService.instance().</code><code>newWriteLock(entity,
 owner, durationSecs);</code><br>
    <code></code></blockquote>
    
      <p>Once the client has the lock, it communicates with the underlying
service  implementation via the lock: </p>
        
      <blockquote><code> lock.convert(IEntityLockService.WRITE_LOCK); // convert
read to write<br>
    </code>...<br>
    <code> if ( lock.isValid() ) &nbsp;// check if lock has expired<br>
  {<br>
  &nbsp; &nbsp; entity.update();<br>
  &nbsp; &nbsp; lock.release();<br>
  }</code><code></code></blockquote>
   <big><a name="Notes_on_Service_Implementations"></a>Notes on Service Implementations</big><br>
    
      <p>A number of concurrency attributes can be configured in the portal.properties
 file.&nbsp; See the section labeled &#8220;Concurrency Services settings&#8221; for
details.</p>
   
      <p><i>Single-server vs. multi-server.</i>&nbsp; The concurrency services
operate  in either single-server or multi-server mode.&nbsp; In single-server
mode,  locks are held in memory. &nbsp;There is no need to invalidate entries
in  peer caches; there are no peers. &nbsp;In multi-server mode, locks are
stored  in the portal database, which is shared by all server clones.&nbsp;
Each time a cache entry is updated or removed, the cache adds an invalidation
to the invalidation store, which is likewise held in the portal database.&nbsp;
Caches periodically retrieve invalidations from the store and purge invalid
entries.</p>
    
      <p><i> Multi-server mode and pooled database connections.</i>&nbsp;
If the portal is running on a single server, concurrency services should
run in single-server  mode, since running in multi-server mode imposes an
extra expense on the portal.&nbsp; However, if the portal is running in a
multi-server environment, you must run in multi-server mode for locking and
caching to function properly.&nbsp; In multi-server mode, these services
make frequent hits to the portal database using connections obtained from
      <code>org.jasig.portal.RDBMServices</code>.&nbsp;  As a result, RDBMServices
must have a source of pooled database connections,  presumably a DataSource,
or else the concurrency services themselves will  become performance bottlenecks.
&nbsp;</p>
    
      <p> <i> The Cache Cleanup Cycle.</i>&nbsp; Each cache instance runs
a cleanup  thread that periodically wakes up and invokes a cleanup routine
to purge the cache of stale entries.&nbsp; The interval between cleanups
is configurable  in portal.properties.&nbsp; In multi-server mode, the cache
first retrieves  and processes its invalidations.&nbsp; In either case, if
the cache is larger  than its maximum size, the cleanup routine removes least
recently used cache  entries until the cache no longer exceeds its maximum
size. </p>
    
      <p> <i>Future enhancements.</i> &nbsp;Caches are now created as needed.&nbsp; 
 Perhaps they should be created and pre-populated on service start-up, kicked 
 off by an entry in services.xml. &nbsp;The caching properties might be better
 represented in xml format. </p>
    <br>
   <i>de 1/23/03</i><br>
   <br>
        <!-- end cut this section to put into jasig table cell format -->
          <br>
             <!-- end of main body table cell -->
  </BODY>
</HTML>